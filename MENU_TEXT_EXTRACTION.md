# Menu Text Extraction Investigation

## Summary

Investigation into why the query "what is the text of user input choices for the main menu" returns "not present in retrieved context" despite menu text existing in COBOL source files.

**Status**: Infrastructure implemented, awaiting copybook indexing.

---

## Implementation Completed

### 1. LABEL Statement Extraction ✅

**Files Modified:**
- `build_screen_nodes.py`: Added `extract_label_literals()` function
- `create_screen_nodes_index.py`: Added `label_literals_json` field to schema

**Pattern Captured:**
```cobol
01  OPMENU-SCREEN.
    03  LABEL LINE 05 COL 02
        "1. ADVERTISING / SOLICITATION"
        LOW.
```

**Result:**
- Extracts line number, column number, and literal text
- Stores as JSON array in searchable field
- 1,582 screen nodes rebuilt with new field

### 2. VALUE Clause Regex Enhancement ✅

**Files Modified:**
- `ingest_cobol_data_items.py`: Enhanced `VALUE_RE` pattern

**Old Pattern:**
```python
VALUE_RE = re.compile(r"VALUE\s+(?:IS\s+)?(['\"]?)([^'\".\s]+)\1", re.IGNORECASE)
# Problem: [^'\".\s]+ excludes whitespace, so "VALUE ' INTERRUPT OPTIONS'" didn't match
```

**New Pattern:**
```python
VALUE_RE = re.compile(r"VALUE\s+(?:IS\s+)?(?:(['\"])([^'\"]*)\1|([A-Z0-9-]+))", re.IGNORECASE)
# Handles: VALUE "text with spaces", VALUE 'text', VALUE SPACES
```

**Multi-line Support Added:**
```python
# Check next line if VALUE not on current line
if not value_clause and idx < len(lines):
    next_line = lines[idx].strip()
    if next_line and not LEVEL_RE.match(next_line.expandtabs()):
        value_m_next = VALUE_RE.search(next_line)
        if value_m_next:
            value_clause = value_m_next.group(2) if value_m_next.group(2) is not None else value_m_next.group(3)
```

**Test Results:**
```
✅ VALUE " INTERRUPT OPTIONS" → " INTERRUPT OPTIONS"
✅ VALUE "010 " → "010 "
✅ VALUE SPACES → "SPACES"
✅ VALUE IS "HELLO WORLD" → "HELLO WORLD"
```

---

## Architecture Discovery

### OTIS Menu System Uses TWO Patterns

#### Pattern A: LABEL-based (LIBSP menus)
**Examples:** OPMENU, BPMENU, SPMENU, LPMENU

**Location:** `*_SCN.CPY` files (screen layout copybooks)

**Format:**
```cobol
01  OPMENU-SCREEN.
    03  LABEL LINE 05 COL 02
        "1. ADVERTISING / SOLICITATION"
        LOW.
    03  LABEL LINE 06 COL 02
        "2. GENERAL LEDGER"
        LOW.
```

**Verification:**
```powershell
Get-Content cobol_src\LIBSP\OPMENU_SCN.CPY | Select-String -Pattern "LABEL"
# Found: 11 LABEL statements with menu option text
```

#### Pattern B: VALUE-based (LIBWI menus)
**Examples:** PGMENU (Interrupt menu)

**Location:** `*_WKS.CPY` files (working storage copybooks)

**Format:**
```cobol
03  PGMENU-TITLE        PIC X(19)
    VALUE " INTERRUPT OPTIONS".
03  PGMENU-WSEL         PIC X(30)
    VALUE " F7, SELECT AN OPTION (RTN):".
03  PGMENU-010          PIC X(29) VALUE SPACES.
03  PGMENU-020          PIC X(29) VALUE SPACES.
```

**Note:** Individual menu option descriptions stored as `VALUE SPACES` (populated at runtime from data files).

### Copybook File Structure

Each menu has 4 associated copybooks:
- `*_DEF.CPY`: Field position definitions
- `*_WKS.CPY`: Working storage with titles/prompts
- `*_SCN.CPY`: Screen layout with LABEL statements  
- `*_EVA.CPY`: Validation logic

**Directories:**
- LIBWI: General working storage copybooks
- LIBSP: Special processing copybooks
- LIBLP: Loan processing copybooks

---

## Root Cause Analysis

### Why Menu Text Is Not Retrievable

**Problem Chain:**
1. Menu SCREEN SECTION content is in copybooks (`*.CPY` files)
2. Copybooks are **NOT** in the `new_code_chunks` index
3. `build_screen_nodes.py` reads from `code_chunks` to extract SCREEN SECTION
4. Therefore, copybook SCREEN sections are never processed
5. Result: **0 menu programs in screen_nodes**

**Verification:**
```python
# Searched for menu programs in screen_nodes
for prog in ['PGMENU', 'OPMENU', 'SPMENU', 'LPMENU', 'BPMENU']:
    results = client.search(filter=f"program_id eq '{prog}'")
    # Result: 0 documents found for all menu programs
```

### Secondary Issue: Copybook VALUE Clauses

**Problem:**
- Copybooks don't have `DATA DIVISION` markers
- `ingest_cobol_data_items.py` requires DATA DIVISION to start parsing
- Result: Copybook VALUE clauses not indexed in `data_items`

**Example:**
```cobol
*------------------------------------------------------------------
* DO NOT MODIFY THIS COPY MEMBER DIRECTLY.
* CODE CONTAINED HERE WAS GENERATED BY THE FORM CONVERSION PROGRAM.
*------------------------------------------------------------------
01  PGMENU-FORM-FIELDS.
    03  PGMENU-TITLE        PIC X(19)
        VALUE " INTERRUPT OPTIONS".
```

No `DATA DIVISION` line → parser skips file → VALUE clause not extracted.

---

## Solution Path

### Required: Add Copybooks to Code Chunks Index

**Current chunking process:**
1. Reads `.CBL` program files from `cobol_src/`
2. Creates overlapping chunks (1500 lines, 300 overlap)
3. Uploads to `new_code_chunks` index
4. `build_screen_nodes.py` searches chunks for "SCREEN SECTION"

**Needed enhancement:**
1. **Include `.CPY` files** in chunking process
2. Treat copybooks same as programs (chunk with overlap)
3. Index into `new_code_chunks` (or separate `copybook_chunks` index)
4. Re-run `build_screen_nodes.py` to extract LABEL statements

**Implementation Options:**

#### Option A: Modify Existing Chunking Script
```python
# In chunking script, change file pattern from:
file_pattern = "*.CBL"
# To:
file_patterns = ["*.CBL", "*.CPY", "*.cpy"]
```

#### Option B: Create Separate Copybook Chunking Process
- Keep program chunks separate from copybook chunks
- Create `copybook_chunks` index
- Modify `build_screen_nodes.py` to search both indexes

**Recommendation:** Option A (simpler, treats copybooks as first-class code)

### Alternative: Direct Copybook SCREEN SECTION Extraction

If chunking is complex, could create targeted extraction:

```python
def process_copybooks_for_screen_sections():
    """Process *.CPY files directly, skip chunking."""
    for copybook_path in glob('cobol_src/**/*.CPY', recursive=True):
        content = read_file(copybook_path)
        if 'SCREEN SECTION' in content:
            sections = extract_screen_sections(content)
            for sec in sections:
                label_literals = extract_label_literals(sec)
                # Create screen_node document
                # Upload to screen_nodes index
```

---

## Current System State

### Indexes Updated ✅
```
new_cobol_screen_nodes: 1,582 documents
- Added field: label_literals_json (searchable)
- LABEL extraction working for programs
- Menu programs: 0 (copybooks not indexed)

new_cobol_data_items: 145,532 documents  
- Added field: value_clause (searchable)
- VALUE regex improved (handles spaces)
- Copybook items: 597 (but no VALUE clauses due to DATA DIVISION requirement)
```

### What Currently Works ✅
- LABEL extraction from program SCREEN SECTION
- VALUE clause extraction from program DATA DIVISION
- Multi-line VALUE clause parsing
- Quoted text with spaces in VALUE clauses

### What Doesn't Work Yet ❌
- Menu text retrieval (copybooks not in chunks)
- LIBSP menu LABEL statements (OPMENU, BPMENU, etc.)
- LIBWI menu VALUE clauses (PGMENU)

---

## Next Steps

### Priority 1: Index Copybooks
1. Identify chunking script (likely in `ingest/` directory)
2. Add `.CPY` files to chunking process
3. Re-run chunking for LIBWI, LIBSP, LIBLP directories
4. Verify copybooks appear in chunks index

### Priority 2: Extract Menu SCREEN Sections
1. Run `build_screen_nodes.py` after copybooks chunked
2. Verify menu programs appear in screen_nodes:
   ```python
   # Should find documents for:
   # OPMENU, BPMENU, SPMENU, LPMENU (LIBSP - LABEL statements)
   # PGMENU (LIBWI - may have different structure)
   ```

### Priority 3: Test Menu Text Query
1. Query RAG system: "what is the text of user input choices for the main menu"
2. Verify retrieved context includes LABEL literal text
3. Check LLM can quote actual menu options

### Priority 4: Embed Menu Content
1. After screen_nodes populated, backfill embeddings
2. Run `backfill_screen_node_embeddings.py` (if exists)
3. Or add vector field and embed manually

---

## Testing Verification

### Test Scripts Created

**LABEL Extraction Test:**
```bash
python check_label_coverage.py
# Found screens with LABEL statements
# Verified extraction working for programs
```

**VALUE Regex Test:**
```bash
python test_value_regex.py
# Confirmed: " INTERRUPT OPTIONS" extracted correctly
# Confirmed: Multi-line VALUES work
```

**Menu Screen Nodes Check:**
```bash
python check_menu_screen_nodes.py
# Result: 0 menu programs in screen_nodes (expected - copybooks not chunked)
```

**Copybook Ingestion Check:**
```bash
python check_copybook_ingestion.py
# Result: 597 copybook items, but no VALUE clauses (no DATA DIVISION)
```

---

## Code Commits

**Local commits (not pushed due to git history issues):**

1. `0bd8c72` - "Add LABEL statement extraction for screen nodes"
   - Implemented extract_label_literals()
   - Added label_literals_json field
   - Rebuilt screen_nodes index
   
2. `c539538` - "Improve VALUE clause regex to handle multi-line and quoted text with spaces"
   - Enhanced VALUE_RE pattern
   - Added lookahead for next line
   - Updated extraction code

3. `673a2cf` - "Remove large JSONL files from git tracking and update .gitignore"
   - Cleaned up repository
   - Added *.jsonl to .gitignore

---

## References

### Key Files

**Enhancement Scripts:**
- `build_screen_nodes.py` - LABEL extraction (line 92-139)
- `ingest_cobol_data_items.py` - VALUE extraction (line 35, 143-152)
- `create_screen_nodes_index.py` - Schema (line 32)

**Test/Debug Scripts:**
- `check_label_coverage.py` - Verify LABEL extraction
- `test_value_regex.py` - Test regex patterns
- `check_menu_screen_nodes.py` - Check menu program coverage
- `check_copybook_ingestion.py` - Verify copybook items

**Copybook Locations:**
- `cobol_src/LIBWI/*.CPY` - General copybooks (PGMENU)
- `cobol_src/LIBSP/*.CPY` - Special processing (OPMENU, BPMENU, etc.)
- `cobol_src/LIBLP/*.CPY` - Loan processing

### Example Menu Copybooks

**OPMENU_SCN.CPY** (LIBSP):
```cobol
01  OPMENU-SCREEN.
    03  LABEL LINE 05 COL 02 "1. ADVERTISING / SOLICITATION" LOW.
    03  LABEL LINE 05 COL 42 "12. BANK PROCESSING MENU" LOW.
    03  LABEL LINE 06 COL 02 "2. GENERAL LEDGER" LOW.
    03  LABEL LINE 22 COL 29 "F7 - MASTER MENU" LOW.
    03  LABEL LINE 23 COL 29 "ENTER SELECTION :" LOW.
```

**PGMENU_WKS.CPY** (LIBWI):
```cobol
01  PGMENU-FORM-FIELDS.
    03  PGMENU-TITLE        PIC X(19) VALUE " INTERRUPT OPTIONS".
    03  PGMENU-WSEL         PIC X(30) VALUE " F7, SELECT AN OPTION (RTN):".
    03  PGMENU-010          PIC X(29) VALUE SPACES.
```

---

## Conclusion

**Infrastructure Complete:** LABEL extraction and VALUE parsing fully implemented and tested.

**Blocker Identified:** Copybooks not in code chunks index.

**Solution Clear:** Add copybooks to chunking pipeline.

**Effort Required:** Low - likely single config change in chunking script.

Once copybooks are chunked, menu text will be immediately searchable through the RAG system with no further code changes needed.
